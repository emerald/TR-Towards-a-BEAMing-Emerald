\section{Emerald and the Emerald VM}

Emerald is a general-purpose programming language, designed in the
early 1980s, in an academic effort to address the challenge of
programming distributed systems. This effort culminated in numerous
academic publications\cite{emerald:tse:1987, emerald:tocs:1988,
emerald:spe:1991} and PhD theses\cite{emerald:phd:norman-c-hutchinson,
emerald:phd:eric-jul, emerald:phd:niels-christian-juul}. However,
Emerald has gained little ground as a programming language --- it
remains only narrowly used in small, academic circles. As such, the
elements of the Emerald programming environment are only piecewise
efficient, robust, and well-documented.

Emerald is a statically-typed, compiled, object-based language. It is
``object-based'', and not ``object-oriented'' in the sense that
(almost) everything is an object (as in Smalltalk), and it uses
\emph{structural subtyping} (as in Go), rather than \emph{nominal
subtyping} (as in Java or C\#). The Emerald type-system also boasts
parametric polymorphism, and a hint of (compiled away) dependent
types.

The key distribution features of Emerald are \emph{fine-grained
mobility} and \emph{location transparency}: anything, from values of
basic types to large objects, can be moved around, and the location of
an object is transparent to the programmer.

Emerald programs are compiled into bytecode for an Emerald-specific
virtual machine (also called the
``kernel''\cite{emerald:phd:eric-jul}). The Emerald VM was crafted
around the same time as Emerald itself.  Unlike the Emerald
programming model, it has received less academic scrutiny. Chances
are, the Emerald VM is severely outdated, and it is no match for a
more modern distributed VM.

This claim however, warrants further investigation. After-all, Emerald
and the Emerald VM were specifically designed to address some the
performance shortcomings of the distributed systems programming
languages at the time\cite{emerald:phd:eric-jul}. Specifically,
Emerald attempted to keep execution of local code efficient, while
sacrificing the efficiency of mobility. The reason being that network
operations take such a long time anyway, that mobility could take the
extra costs. This has not changed. Network operations are still the
ones that take the longest. However, what is locally efficient,
robust, and considered secure has changed. Especially in the face of
more heterogeneous systems.
