\section{Running Anything on the BEAM}

Due to the Erlang/OTP infrastructure, there are a number of possible
code generation targets, if we would like to run our code on the BEAM.

For starters, there is \emph{Erlang source code} (usual
file-extension: \texttt{.erl}) and \emph{BEAM bytecode} (usual
file-extension: \texttt{.beam}). Neither of these have up-to-date
specification documents\footnote{The last Erlang language
specification was written up in 1999\cite{erlang:1999:spec}. It
attained only a draft form, and is today considered rather outdated.
See also \url{https://github.com/erlang/spec}.}, let alone any formal
specifications. However, due to Erlang being a fairly popular
programming language\footnote{See Appendix
\longref{app:popularity-of-erlang} for an analysis of the popularity
of Erlang.}, there is a wealth of literature on programming
Erlang\footnote{See also \url{https://www.erlang.org/docs}.}.  In
general however, the best specification of both, is the Erlang/OTP
implementation itself\footnote{See Appendix
\longref{app:overview-of-erlang-source} for an overview of the
Erlang/OTP source code.}.

Erlang source code and BEAM bytecode are a world apart. The first is a
high-level functional programming language. The second is a low-level
bytecode for a register-based virtual machine. To transform one into
the other, the Erlang/OTP compiler performs a number of
transformations and optimizations; passing over the Erlang module
multiple times.

If we generate Erlang source code, we must make sure to efficiently
map our (possibly high-level) model to the high-level Erlang
programming model. If we instead generate BEAM bytecode, we miss out
on the optimizations the Erlang/OTP compiler could have performed for
us.

The Erlang/OTP compiler takes an Erlang module through a number of
intermediate representations. Some of these representations are
serializable---the compiler can both output, and consume files in such
formats. The serializable intermediate representations are \emph{Core
Erlang} (usual file-extension: \texttt{.core}) and \emph{BEAM
assembly} (usual file-extension: \texttt{.beam}). As with Erlang
source code, and BEAM bytecode, these do not have up-to-date
specifications, beyond the Erlang/OTP implementation itself.

All the serializable representations along a happy path through the
Erlang/OTP compiler are illustrated in Figure
\ref{fig:serializable-representations}. Generating code in any of
these formats, would allow us to run code on the BEAM, by leveraging
the file-based API of the Erlang/OTP compiler only. 

\NewDocumentCommand\optimizing{}{$\circlearrowright$}

\begin{figure}[h]
\centering
\tikzstyle{block} = [rectangle, draw, 
    text width=4.5em, text centered, rounded corners,
    rectangle split, rectangle split parts=2,
    rectangle split draw splits=true,
    node distance=7em]
\tikzstyle{line} = [draw, -latex']
\tikzstyle{wrapper} = [rectangle, draw, dashed, rounded corners]
\tikzstyle{optimizing} = [line width=0.2em]

\begin{tikzpicture}[auto]
\node (source) [block] {
  \nodepart{one} Erlang source code
  \nodepart{two} \texttt{.erl}
};
\node (core) [block, right of=source] {
  \nodepart{one} Core Erlang\\ \optimizing{}
  \nodepart{two} \texttt{.core}
};
\node (asm) [block, right of=core] {
  \nodepart{one} BEAM assembly\\ \optimizing{}
  \nodepart{two} \texttt{.S}
};
\node (bin) [block, right of=asm] {
  \nodepart{one} BEAM bytecode\\ ~
  \nodepart{two} \texttt{.beam}
};
\node (functional) [wrapper, fit={(source) (core)}, label=below:{\emph{Functional}}] {};
\node (imperative) [wrapper, fit={(asm) (bin)}, label=below:{\emph{Imperative}}] {};
\path [line] (source) -> (core);
\path [line] (core) -> (asm);
\path [line] (asm) -> (bin);
\end{tikzpicture}

\caption{Serializable representations along the path of a valid module
through the passes of the Erlang/OTP compiler. The symbol
\optimizing{} marks the formats on which the compiler performs crucial
optimisations.}

\label{fig:serializable-representations}
\end{figure}

\subsection{Compiling Erlang source code to BEAM bytecode}

Erlang source code can be transformed into BEAM bytecode using the
Erlang compiler in Erlang/OTP. There are two entry-point binaries,
which we can use to interface with the compiler:

\begin{enumerate}

\item the Erlang compiler binary, \texttt{erlc}; and

\item the Erlang emulator and/or interactive shell, \texttt{erl}.

\end{enumerate}

For instance, assume that we have a file called \texttt{m.erl},
containing the source code of an Erlang module. We can compile it to
an \texttt{m.beam}, containing BEAM bytecode for that module, using
either of the ways shown in Figure \ref{fig:erlc}. These approaches
are non-interactive, in the sense that code is passed in, and passed
out via files, rather than standard input/output. Warnings and errors
however, are still written to standard output/error, in a
human-readable fashion.

\begin{figure}[h!]
\begin{minipage}[t]{0.5\textwidth}
\begin{lstlisting}
$ erlc m.erl
\end{lstlisting}
\end{minipage}%
\begin{minipage}[t]{0.5\textwidth}
\begin{lstlisting}
$ erl -compile m.erl
\end{lstlisting}
\end{minipage}%
\caption{A couple ``non-interactive'' ways to compile an Erlang
module.}
\label{fig:erlc}
\end{figure}

In either case, the work is done by the built-in \texttt{compile}
library in Erlang/OTP. This means that an Erlang module can also be
compiled in a more interactive fashion, using \texttt{erl}. The
potential benefit of this approach is that warnings and errors can
remain in a more machine-readable format (i.e., Erlang terms, not
bytes on a stream). This approach is illustrated in Figure
\ref{fig:erl-c}.

\begin{figure}[h!]
\begin{minipage}[t]{0.2\textwidth}
\begin{lstlisting}
$ erl
...
1> R = c(m).
2>
\end{lstlisting}
\end{minipage}%
\begin{minipage}[t]{0.35\textwidth}
\begin{lstlisting}
$ erl
...
1> R = compile:file(m).
2>
\end{lstlisting}
\end{minipage}%
\begin{minipage}[t]{0.45\textwidth}
\begin{lstlisting}
$ erl
...
1> R = compile:file(m, [return]).
2>
\end{lstlisting}
\end{minipage}%
\caption{A couple ``interactive'' ways to compile an Erlang module.
The variable \texttt{R} will contain information on the outcome of the
compilation. \texttt{c} is a simple variant of \texttt{compile:file}.
The right-most example will actually yield errors and warnings (if
any) as Erlang terms, inside the compound term \texttt{R}.}
\label{fig:erl-c}
\end{figure}

\subsection{Running BEAM bytecode}

Once compiled, the module code can be executed using \texttt{erl}.
Again, there is a non-interactive, and an interactive option.

\subsection{Core Erlang and BEAM assembly}

Generating code in any of the formats listed in Figure
\ref{fig:serializable-representations}, would allow us to run code on
the BEAM, by leveraging the command-line API of the Erlang/OTP
compiler only. In particular:

\begin{table}[h]

\centering

\renewcommand*{\arraystretch}{1.5}

\begin{tabular}{|l|l|}
\hline%
\multicolumn{2}{|l|}{%
  \textbf{To generate BEAM bytecode from Erlang source code}%
}\\\hline%
\emph{Command} & \emph{Effect} \\\hline
  \lstinline[]!erlc module.erl! &%
  Generates an Erlang BEAM file \texttt{module.beam}
\\\hline%
\multicolumn{2}{|l|}{%
  \textbf{To generate BEAM assembly from Erlang source code}%
}\\\hline%
\emph{Command} & \emph{Effect} \\\hline
  \lstinline[]!erlc -S module.erl! &%
  Generates an ASCII text file \texttt{module.S}
\\\hline%
\multicolumn{2}{|l|}{%
  \textbf{To generate BEAM assembly from Erlang source code}%
}\\\hline%
\emph{Command} & \emph{Effect} \\\hline
  \lstinline[]!erlc -S module.erl! &%
  Generates an ASCII text file \texttt{module.S}
\\\hline%
\multicolumn{2}{|l|}{%
  \textbf{To generate Core Erlang code from Erlang source code}%
}\\\hline%
\emph{Command} & \emph{Effect} \\\hline
  \lstinline[]!erlc +to_core module.erl! &%
  Generates an ASCII text file \texttt{module.core}
\\\hline%
\end{tabular}

\end{table}

\begin{figure}[h]
\centering
\tikzstyle{block} = [rectangle, draw, 
    text width=6em, text centered, rounded corners,
    node distance=3em,
    minimum height=3em]
\tikzstyle{line} = [draw, -latex']
\tikzstyle{optimizing} = [line width=0.2em]
\footnotesize
\begin{tikzpicture}[auto]
\node (bin) [block] {%
  BEAM bytecode
  \texttt{m.beam}%
};
\node (source) [block, left=9em of bin] {%
  Erlang source code\\
  \texttt{m.erl}%
};
\node (asm) [block, below=3em of bin] {%
  BEAM assembly\\
  \texttt{m.S}%
};
\node (core) [block, below=3em of asm] {%
  Core Erlang
  \texttt{m.core}%
};
\path [line] (source) edge (bin);
\path [line] (source) edge [bend right=30] node [below left] {%
  \lstinline{+to_core}%
} (core);
\path [line] (source) edge [bend right=20] node [above right=0.5em] {%
  \lstinline{+to_asm} (or \lstinline{-S})%
} (asm);
\path [line] (core) edge [bend right=40] node [left] {%
  \lstinline{+to_asm} (or \lstinline{-S})%
} (asm);
\path [line] (core) edge [bend right=90] (bin);
\path [line] (asm) edge [bend right=40] (bin);
\end{tikzpicture}

\caption{An illustration of the options to pass to \texttt{erlc},
depending on the input file, and desired output file. No options are
necessary, if the desired output is a BEAM bytecode file
(\texttt{.beam})}
\label{fig:serializable-representations}
\end{figure}

However, the Erlang/OTP compiler is an optimising compiler. Various
optimisations are performed on both the Core Erlang representation,
and the BEAM assembly representation. Optimisations take place in two
stages because the two representations suitable for each their own
class of optimisations. In particular, Core Erlang is a piecewise
functional language, while BEAM assembly is inherently imperative.

Depending on the extent of optimisations that we conduct ourselves, it
may be better to generate code in on of the earlier, rather than
latter formats.

% Probably the best-specified and most stable of these is Core
% Erlang\cite{erlang:erlang:2001:core-intro, erlang:2004:core-spec}.

% Erlang The BEAM Book suggests that ``Core Erlang is the best target
% for a language you want to run in ERTS''. The reasons mentioned are
% that Core Erlang is less subject to change than the languages of
% BEAM and Erlang.

% https://github.com/erlang/otp/blob/master/lib/compiler/src/cerl.erl
