\section{Running Anything on the BEAM}

Due to the Erlang/OTP infrastructure, there are a number of possible
code generation targets, if we would like to run our code on the BEAM.



For starters, there is \emph{Erlang source code} and \emph{BEAM
bytecode}. Neither of these have up-to-date specification
documents\footnotemark, let alone any formal specifications. The best
specification of both is the Erlang/OTP implementation itself. See
Appendix \longref{app:overview-of-erlang-source} for an overview of
the Erlang/OTP source code.

\footnotetext{The last Erlang language specification was written up in
1999\cite{erlang:1999:spec}. It attained only a draft form, and is
today considered rather outdated. See also
\url{https://github.com/erlang/spec}.}

The Erlang/OTP compiler is a multi-pass compiler. As such, it takes a
valid Erlang program through a number of intermediate representations.
Some of these representations are serializable in the following sense:
the compiler can produce, and take in files in these formats, omitting
subsequent, or preceding passes. The serializable representations
along a happy path through the Erlang/OTP compiler are illustrated in
Figure \ref{fig:serializable-representations}.

\NewDocumentCommand\optimizing{}{$\circlearrowright$}

\begin{figure}[h]
\centering
\tikzstyle{block} = [rectangle, draw, 
    text width=4.5em, text centered, rounded corners,
    node distance=7em,
    minimum height=4em]
\tikzstyle{line} = [draw, -latex']
\tikzstyle{optimizing} = [line width=0.2em]

\begin{tikzpicture}[auto]
\node (source) [block] {Erlang source code};
%\node (absform) [block, right of=source] {Erlang Abstract Format};
\node (core) [block, right of=source] {Core Erlang\\ \optimizing{}};
\node (asm) [block, right of=core] {BEAM assembly\\ \optimizing{}};
\node (bin) [block, right of=asm] {BEAM bytecode};
\path [line] (source) -> (core);
%\path [line] (absform) -> (core);
\path [line] (core) -> (asm);
\path [line] (asm) -> (bin);
\end{tikzpicture}

\caption{Serializable representations along the path of a valid
program through the passes of the Erlang/OTP compiler. The symbol
\optimizing{} marks the formats on which the compiler performs crucial
optimisations.}

\label{fig:serializable-representations}
\end{figure}

Generating code in any of the formats listed in Figure
\ref{fig:serializable-representations}, would allow us to run code on
the BEAM, by leveraging the command-line API of the Erlang/OTP
compiler only. In particular:

\begin{table}[h]

\centering

\renewcommand*{\arraystretch}{1.5}

\begin{tabular}{|l|l|}
\hline%
\multicolumn{2}{|l|}{%
  \textbf{To generate BEAM bytecode from Erlang source code}%
}\\\hline%
\emph{Command} & \emph{Effect} \\\hline
  \lstinline[]!erlc module.erl! &%
  Generates an Erlang BEAM file \texttt{module.beam}
\\\hline%
\multicolumn{2}{|l|}{%
  \textbf{To generate BEAM assembly from Erlang source code}%
}\\\hline%
\emph{Command} & \emph{Effect} \\\hline
  \lstinline[]!erlc -S module.erl! &%
  Generates an ASCII text file \texttt{module.S}
\\\hline%
\multicolumn{2}{|l|}{%
  \textbf{To generate BEAM assembly from Erlang source code}%
}\\\hline%
\emph{Command} & \emph{Effect} \\\hline
  \lstinline[]!erlc -S module.erl! &%
  Generates an ASCII text file \texttt{module.S}
\\\hline%
\multicolumn{2}{|l|}{%
  \textbf{To generate Core Erlang code from Erlang source code}%
}\\\hline%
\emph{Command} & \emph{Effect} \\\hline
  \lstinline[]!erlc +to_core module.erl! &%
  Generates an ASCII text file \texttt{module.core}
\\\hline%
\end{tabular}

\end{table}

\begin{figure}[h]
\centering
\tikzstyle{block} = [rectangle, draw, 
    text width=6em, text centered, rounded corners,
    node distance=3em,
    minimum height=3em]
\tikzstyle{line} = [draw, -latex']
\tikzstyle{optimizing} = [line width=0.2em]
\footnotesize
\begin{tikzpicture}[auto]
\node (bin) [block] {%
  BEAM bytecode
  \texttt{m.beam}%
};
\node (source) [block, left=9em of bin] {%
  Erlang source code\\
  \texttt{m.erl}%
};
\node (asm) [block, below=3em of bin] {%
  BEAM assembly\\
  \texttt{m.S}%
};
\node (core) [block, below=3em of asm] {%
  Core Erlang
  \texttt{m.core}%
};
\path [line] (source) edge (bin);
\path [line] (source) edge [bend right=30] node [below left] {%
  \lstinline{+to_core}%
} (core);
\path [line] (source) edge [bend right=20] node [above right=0.5em] {%
  \lstinline{+to_asm} (or \lstinline{-S})%
} (asm);
\path [line] (core) edge [bend right=40] node [left] {%
  \lstinline{+to_asm} (or \lstinline{-S})%
} (asm);
\path [line] (core) edge [bend right=90] (bin);
\path [line] (asm) edge [bend right=40] (bin);
\end{tikzpicture}

\caption{An illustration of the options to pass to \texttt{erlc},
depending on the input file, and desired output file. No options are
necessary, if the desired output is a BEAM bytecode file
(\texttt{.beam})}
\label{fig:serializable-representations}
\end{figure}

However, the Erlang/OTP compiler is an optimising compiler. Various
optimisations are performed on both the Core Erlang representation,
and the BEAM assembly representation. Optimisations take place in two
stages because the two representations suitable for each their own
class of optimisations. In particular, Core Erlang is a piecewise
functional language, while BEAM assembly is inherently imperative.

Depending on the extent of optimisations that we conduct ourselves, it
may be better to generate code in on of the earlier, rather than
latter formats.

% Probably the best-specified and most stable of these is Core
% Erlang\cite{erlang:erlang:2001:core-intro, erlang:2004:core-spec}.

% Erlang The BEAM Book suggests that ``Core Erlang is the best target
% for a language you want to run in ERTS''. The reasons mentioned are
% that Core Erlang is less subject to change than the languages of
% BEAM and Erlang.

% https://github.com/erlang/otp/blob/master/lib/compiler/src/cerl.erl
