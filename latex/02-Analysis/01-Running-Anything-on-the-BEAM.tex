\section{Running Anything on the BEAM}

Due to the Erlang/OTP infrastructure, there are a number of possible
code generation targets, if we would like to run our code on the BEAM.

For starters, there is \emph{Erlang source code} (usual
file-extension: \texttt{.erl}) and \emph{BEAM bytecode} (usual
file-extension: \texttt{.beam}). Neither of these have up-to-date
specification documents\footnotemark, let alone any formal
specifications. However, due to Erlang being a fairly popular
programming language\footnotemark, there is a wealth of literature on
programming Erlang\footnotemark. Never-the-less, the best
specification of both is the Erlang/OTP implementation
itself\footnotemark.

\footnotetext{The last Erlang language specification was written up in
1999\cite{erlang:1999:spec}. It attained only a draft form, and is
today considered rather outdated. See also
\url{https://github.com/erlang/spec}.}

\footnotetext{See Appendix \longref{app:popularity-of-erlang} for an
analysis of the popularity of Erlang.}

\footnotetext{See also \url{https://www.erlang.org/docs}.}

\footnotetext{See Appendix \longref{app:overview-of-erlang-source} for
an overview of the Erlang/OTP source code.}

\subsection{Compiling Erlang source code to BEAM bytecode}

Erlang source code can be transformed into BEAM bytecode using the
Erlang compiler in Erlang/OTP. There are two entry-point binaries,
which we can use to interface with the compiler:

\begin{enumerate}

\item The Erlang compiler binary, \texttt{erlc}.

\item The Erlang emulator and/or interactive shell, \texttt{erl}.

\end{enumerate}

For instance, assume that we have a file called \texttt{m.erl},
containing the source code of an Erlang module. We can compile it to
an \texttt{m.beam}, containing BEAM bytecode for that module, using
either of the ways shown in Figure \ref{fig:erlc}. These approaches
are non-interactive, in the sense that code is passed in, and passed
out via files, rather than standard input/output. Warnings and errors
however, are still written to standard output/error, in a
human-readable fashion.

\begin{figure}[h!]
\begin{minipage}[t]{0.5\textwidth}
\begin{lstlisting}
$ erlc m.erl
\end{lstlisting}
\end{minipage}%
\begin{minipage}[t]{0.5\textwidth}
\begin{lstlisting}
$ erl -compile m.erl
\end{lstlisting}
\end{minipage}%
\caption{A couple ``non-interactive'' ways to compile an Erlang
module.}
\label{fig:erlc}
\end{figure}

In either case, the work is done by the built-in \texttt{compile}
library in Erlang/OTP. This means that an Erlang module can also be
compiled in a more interactive fashion, using \texttt{erl}. The
potential benefit of this approach is that warnings and errors can
remain in a more machine-readable format (i.e., they can be Erlang
terms, not bytes on a stream). This approach is illustrated in Figure
\ref{fig:erl-c}.

\begin{figure}[h!]
\begin{minipage}[t]{0.2\textwidth}
\begin{lstlisting}
$ erl
...
1> R = c(m).
2>
\end{lstlisting}
\end{minipage}%
\begin{minipage}[t]{0.35\textwidth}
\begin{lstlisting}
$ erl
...
1> R = compile:file(m).
2>
\end{lstlisting}
\end{minipage}%
\begin{minipage}[t]{0.45\textwidth}
\begin{lstlisting}
$ erl
...
1> R = compile:file(m, [return]).
2>
\end{lstlisting}
\end{minipage}%
\caption{A couple ``interactive'' ways to compile an Erlang module.
The variable \texttt{R} will contain information on the outcome of the
compilation. \texttt{c} is a simple variant of \texttt{compile:file}.
The right-most example will actually yield errors and warnings (if
any) as Erlang terms inside the compound term \texttt{R}.}
\label{fig:erl-c}
\end{figure}

\subsection{Running BEAM bytecode}

There is no notion of ``running'' an Erlang module

Erlang source code and BEAM bytecode are a world apart. The first is a
high-level functional programming language. The second is a low-level
bytecode for a register-based virtual machine. In-between those, the
Erlang compiler performs a number of transformations and
optimizations. If we generate Erlang source code, we must make sure to
efficiently map our (possibly high-level) model to the Erlang
high-level programming model. If we instead generate BEAM bytecode, we
miss out on the optimizations the Erlang compiler could have performed
for us.

\subsection{Core Erlang and BEAM assembly}

The Erlang/OTP compiler is a multi-pass compiler. As such, it takes at
valid Erlang program through a number of intermediate representations.
Some of these representations are serializable in the following sense:
the compiler can produce, and take in files in these formats, omitting
subsequent, or preceding passes. The serializable representations
along a happy path through the Erlang/OTP compiler are illustrated in
Figure \ref{fig:serializable-representations}.

\NewDocumentCommand\optimizing{}{$\circlearrowright$}

\begin{figure}[h]
\centering
\tikzstyle{block} = [rectangle, draw, 
    text width=4.5em, text centered, rounded corners,
    node distance=7em,
    minimum height=4em]
\tikzstyle{line} = [draw, -latex']
\tikzstyle{optimizing} = [line width=0.2em]

\begin{tikzpicture}[auto]
\node (source) [block] {Erlang source code};
%\node (absform) [block, right of=source] {Erlang Abstract Format};
\node (core) [block, right of=source] {Core Erlang\\ \optimizing{}};
\node (asm) [block, right of=core] {BEAM assembly\\ \optimizing{}};
\node (bin) [block, right of=asm] {BEAM bytecode};
\path [line] (source) -> (core);
%\path [line] (absform) -> (core);
\path [line] (core) -> (asm);
\path [line] (asm) -> (bin);
\end{tikzpicture}

\caption{Serializable representations along the path of a valid
program through the passes of the Erlang/OTP compiler. The symbol
\optimizing{} marks the formats on which the compiler performs crucial
optimisations.}

\label{fig:serializable-representations}
\end{figure}

Generating code in any of the formats listed in Figure
\ref{fig:serializable-representations}, would allow us to run code on
the BEAM, by leveraging the command-line API of the Erlang/OTP
compiler only. In particular:

\begin{table}[h]

\centering

\renewcommand*{\arraystretch}{1.5}

\begin{tabular}{|l|l|}
\hline%
\multicolumn{2}{|l|}{%
  \textbf{To generate BEAM bytecode from Erlang source code}%
}\\\hline%
\emph{Command} & \emph{Effect} \\\hline
  \lstinline[]!erlc module.erl! &%
  Generates an Erlang BEAM file \texttt{module.beam}
\\\hline%
\multicolumn{2}{|l|}{%
  \textbf{To generate BEAM assembly from Erlang source code}%
}\\\hline%
\emph{Command} & \emph{Effect} \\\hline
  \lstinline[]!erlc -S module.erl! &%
  Generates an ASCII text file \texttt{module.S}
\\\hline%
\multicolumn{2}{|l|}{%
  \textbf{To generate BEAM assembly from Erlang source code}%
}\\\hline%
\emph{Command} & \emph{Effect} \\\hline
  \lstinline[]!erlc -S module.erl! &%
  Generates an ASCII text file \texttt{module.S}
\\\hline%
\multicolumn{2}{|l|}{%
  \textbf{To generate Core Erlang code from Erlang source code}%
}\\\hline%
\emph{Command} & \emph{Effect} \\\hline
  \lstinline[]!erlc +to_core module.erl! &%
  Generates an ASCII text file \texttt{module.core}
\\\hline%
\end{tabular}

\end{table}

\begin{figure}[h]
\centering
\tikzstyle{block} = [rectangle, draw, 
    text width=6em, text centered, rounded corners,
    node distance=3em,
    minimum height=3em]
\tikzstyle{line} = [draw, -latex']
\tikzstyle{optimizing} = [line width=0.2em]
\footnotesize
\begin{tikzpicture}[auto]
\node (bin) [block] {%
  BEAM bytecode
  \texttt{m.beam}%
};
\node (source) [block, left=9em of bin] {%
  Erlang source code\\
  \texttt{m.erl}%
};
\node (asm) [block, below=3em of bin] {%
  BEAM assembly\\
  \texttt{m.S}%
};
\node (core) [block, below=3em of asm] {%
  Core Erlang
  \texttt{m.core}%
};
\path [line] (source) edge (bin);
\path [line] (source) edge [bend right=30] node [below left] {%
  \lstinline{+to_core}%
} (core);
\path [line] (source) edge [bend right=20] node [above right=0.5em] {%
  \lstinline{+to_asm} (or \lstinline{-S})%
} (asm);
\path [line] (core) edge [bend right=40] node [left] {%
  \lstinline{+to_asm} (or \lstinline{-S})%
} (asm);
\path [line] (core) edge [bend right=90] (bin);
\path [line] (asm) edge [bend right=40] (bin);
\end{tikzpicture}

\caption{An illustration of the options to pass to \texttt{erlc},
depending on the input file, and desired output file. No options are
necessary, if the desired output is a BEAM bytecode file
(\texttt{.beam})}
\label{fig:serializable-representations}
\end{figure}

However, the Erlang/OTP compiler is an optimising compiler. Various
optimisations are performed on both the Core Erlang representation,
and the BEAM assembly representation. Optimisations take place in two
stages because the two representations suitable for each their own
class of optimisations. In particular, Core Erlang is a piecewise
functional language, while BEAM assembly is inherently imperative.

Depending on the extent of optimisations that we conduct ourselves, it
may be better to generate code in on of the earlier, rather than
latter formats.

% Probably the best-specified and most stable of these is Core
% Erlang\cite{erlang:erlang:2001:core-intro, erlang:2004:core-spec}.

% Erlang The BEAM Book suggests that ``Core Erlang is the best target
% for a language you want to run in ERTS''. The reasons mentioned are
% that Core Erlang is less subject to change than the languages of
% BEAM and Erlang.

% https://github.com/erlang/otp/blob/master/lib/compiler/src/cerl.erl
