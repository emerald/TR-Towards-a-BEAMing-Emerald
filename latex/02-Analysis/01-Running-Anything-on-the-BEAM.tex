\section{Running Anything on the BEAM}

Due to the Erlang/OTP infrastructure, there are a number of possible
code generation targets, if we would like to run our code on the BEAM.

To start, there is \emph{Erlang source code} (usual file-extension:
\texttt{.erl}) and \emph{BEAM bytecode} (usual file-extension:
\texttt{.beam}). Neither of these have up-to-date specification
documents\footnote{The last Erlang language specification was written
up in 1999\cite{erlang:1999:spec}. It attained only a draft form, and
is today considered rather outdated.  See also
\url{https://github.com/erlang/spec}.}, let alone any formal
specifications. However, due to Erlang being a fairly popular
programming language\footnote{See Appendix
\longref{app:popularity-of-erlang} for an analysis of the popularity
of Erlang.}, there is a wealth of literature on programming
Erlang\footnote{See also \url{https://www.erlang.org/docs}.}.  In
general however, the best specification of both, is the Erlang/OTP
implementation itself\footnote{See Appendix
\longref{app:overview-of-erlang-source} for an overview of the
Erlang/OTP source code.}.

Erlang source code and BEAM bytecode are a world apart. The first is a
high-level functional programming language. The second is a low-level
bytecode for a register-based virtual machine. To transform one into
the other, the Erlang/OTP compiler performs a number of
transformations and optimizations; passing over the Erlang module
multiple times.

If we generate Erlang source code, we must make sure to efficiently
map our (possibly high-level) model to the high-level Erlang
programming model. If we instead generate BEAM bytecode, we miss out
on the optimizations the Erlang/OTP compiler could have performed for
us.

Furthermore, the Erlang/OTP compiler takes an Erlang module through a
number of intermediate representations. Some of these representations
are serializable---the compiler can both output, and consume files in
such formats. The serializable intermediate representations are
\emph{Core Erlang} (usual file-extension: \texttt{.core}) and
\emph{BEAM assembly} (usual file-extension: \texttt{.S}). As with
Erlang source code, and BEAM bytecode, these do not have up-to-date
specifications, beyond the Erlang/OTP implementation itself.

All the serializable representations along a happy path through the
Erlang/OTP compiler are illustrated in Figure
\ref{fig:serializable-representations}. Generating code in any of
these formats, would allow us to run code on the BEAM, by leveraging
the file-based API of the Erlang/OTP compiler only. 

\NewDocumentCommand\optimizing{}{$\circlearrowright$}

\begin{figure}[ht!]
\centering
\tikzstyle{block} = [rectangle, draw, 
    text width=4.5em, text centered, rounded corners,
    rectangle split, rectangle split parts=2,
    rectangle split draw splits=true,
    node distance=7em]
\tikzstyle{line} = [draw, -latex']
\tikzstyle{wrapper} = [rectangle, draw, dashed, rounded corners]
\tikzstyle{optimizing} = [line width=0.2em]

\begin{tikzpicture}[auto]
\node (source) [block] {
  \nodepart{one} Erlang source code
  \nodepart{two} \texttt{.erl}
};
\node (core) [block, right of=source] {
  \nodepart{one} Core Erlang\\ \optimizing{}
  \nodepart{two} \texttt{.core}
};
\node (asm) [block, right of=core] {
  \nodepart{one} BEAM assembly\\ \optimizing{}
  \nodepart{two} \texttt{.S}
};
\node (bin) [block, right of=asm] {
  \nodepart{one} BEAM bytecode\\ ~
  \nodepart{two} \texttt{.beam}
};
\node (functional) [wrapper, fit={(source) (core)}, label=below:{\emph{Functional}}] {};
\node (imperative) [wrapper, fit={(asm) (bin)}, label=below:{\emph{Imperative}}] {};
\path [line] (source) -> (core);
\path [line] (core) -> (asm);
\path [line] (asm) -> (bin);
\end{tikzpicture}

\caption{Serializable representations along the path of a valid module
through the passes of the Erlang/OTP compiler. The symbol
\optimizing{} marks the formats on which the compiler performs crucial
optimisations.}

\label{fig:serializable-representations}
\end{figure}

The following subsections detail how to use the Erlang/OTP
infrastructure to go from Erlang source code to BEAM bytecode, how to
run BEAM bytecode, and how to generate and pass in code in, and
further detail the aforementioned intermediate representations.

\subsection{Compiling Erlang source code to BEAM bytecode}

Erlang source code can be transformed into BEAM bytecode using the
Erlang compiler in Erlang/OTP. There are two entry-point binaries,
which we can use to interface with the compiler:

\begin{enumerate}

\item the Erlang compiler binary, \texttt{erlc}; and

\item the Erlang emulator and/or interactive shell, \texttt{erl}.

\end{enumerate}

For instance, assume that we have a file called \texttt{m.erl},
containing the source code of an Erlang module. We can compile it to
an \texttt{m.beam}, containing BEAM bytecode for that module, using
either of the ways shown in Figure \ref{fig:erlc}. These approaches
are non-interactive, in the sense that code is passed in, and passed
out via files, rather than standard input/output. Warnings and errors
however, are still written to standard output/error, in a
human-readable fashion.

\begin{figure}[ht!]
\begin{minipage}[t]{0.5\textwidth}
\begin{lstlisting}
$ erlc m.erl
\end{lstlisting}
\end{minipage}%
\begin{minipage}[t]{0.5\textwidth}
\begin{lstlisting}
$ erl -compile m.erl
\end{lstlisting}
\end{minipage}%
\caption{A couple ``non-interactive'' ways to compile an Erlang
module.}
\label{fig:erlc}
\end{figure}

In either case, the work is done by the \texttt{compile} library in
Erlang/OTP. This means that an Erlang module can also be compiled in a
more interactive fashion, using \texttt{erl}. The potential benefit of
this approach is that warnings and errors can remain in a more
machine-readable format (i.e., Erlang terms, not bytes on a stream).
This approach is illustrated in Figure \ref{fig:erl-c}.

\begin{figure}[ht!]
\begin{minipage}[t]{0.2\textwidth}
\begin{lstlisting}
$ erl
...
1> R = c(m).
2>
\end{lstlisting}
\end{minipage}%
\begin{minipage}[t]{0.35\textwidth}
\begin{lstlisting}
$ erl
...
1> R = compile:file(m).
2>
\end{lstlisting}
\end{minipage}%
\begin{minipage}[t]{0.45\textwidth}
\begin{lstlisting}
$ erl
...
1> R = compile:file(m, [return]).
2>
\end{lstlisting}
\end{minipage}%
\caption{A couple ``interactive'' ways to compile an Erlang module.
The variable \texttt{R} will contain information on the outcome of the
compilation. \texttt{c} is a simple variant of \texttt{compile:file}.
The right-most example will actually yield errors and warnings (if
any) as Erlang terms, inside the compound term \texttt{R}.}
\label{fig:erl-c}
\end{figure}

\subsection{Running BEAM bytecode}

Once compiled, the module code can be executed using \texttt{erl}.
Again, there is a non-interactive, and an interactive option.

\subsection{Core Erlang}

Core Erlang\cite{erlang:erlang:2001:core-intro, erlang:2004:core-spec}
is an intermediate language designed specifically to enable the
Erlang/OTP compiler to leverage the compiler optimizations afforded by
a functional programming language, while not prohibiting the evolution
of either the Erlang syntax and semantics, or the BEAM virtual
machine.

Overall, the Erlang/OTP compiler performs inlining, constant folding,
and common subexpression elimination. The optimizations performed on
Core Erlang code are further detailed in Table
\longref{tbl:core-erlang-optimizations}.

\begin{table}[ht!]
\centering
\def\arraystretch{1.2}
\begin{tabular}{rlr}
\textbf{Order} & \textbf{Module} & \textbf{Lines of Code} \\\cline{2-3}
1 & \texttt{sys\_core\_inline} & 217 \\
  & \multicolumn{2}{l}{\quad\emph{%
      Inlining of small functions.%
    }} \\\cline{2-3}
2 & \texttt{sys\_core\_fold} & 3276 \\
  & \multicolumn{2}{l}{\quad\emph{%
      Constant folding.%
    }} \\\cline{2-3}
3 & \texttt{cerl\_inline} & 2834 \\
  & \multicolumn{2}{l}{\quad\emph{%
      An implementation of the inlining algorithm described in%
      \cite{erlang:sas:1997:inlining}.%
    }} \\\cline{2-3}
4 & \texttt{sys\_core\_fold} & 3276 \\
  & \multicolumn{2}{l}{\quad\emph{%
      Performed once more after inlining.%
    }} \\\cline{2-3}
5 & \texttt{sys\_core\_alias} & 307 \\
  & \multicolumn{2}{l}{\quad\emph{%
      A limited form of common subexpression elimination.%
    }} \\\cline{2-3}
\end{tabular}
\caption{The optimizations performed on Core Erlang by the Erlang/OTP
compiler. All modules are located in \texttt{lib/compiler/src}, and
are called from the \texttt{compile} module, in the given order. Lines
of Code is the raw line-count of the module in Erlang/OTP version
22.1; this gives  a rough idea of where the majority of the work
happens.}
\label{tbl:core-erlang-optimizations}
\end{table}

\texttt{erlc} can produce both optimized and unoptimized Core Erlang
code. For this, it accepts either the arugment \texttt{+to\_core}, or
\texttt{+to\_core0}, respectively. In either case, a \texttt{.core}
file is produced.

If you pass in a \texttt{.core} file to \texttt{erlc}, it will first
attempt to optimize the Core Erlang code, before moving on to the next
compiler stages. \texttt{erlc} takes the optional \texttt{+from\_core}
argument, to explicitly indicate that the incoming file is a Core
Erlang file. However, this argument is assumed for a \texttt{.core}
file.

\subsection{Core Erlang and BEAM assembly}

Generating code in any of the formats listed in Figure
\ref{fig:serializable-representations}, would allow us to run code on
the BEAM, by leveraging the command-line API of the Erlang/OTP
compiler only. In particular:

\begin{table}[h]

\centering

\renewcommand*{\arraystretch}{1.5}

\begin{tabular}{|l|l|}
\hline%
\multicolumn{2}{|l|}{%
  \textbf{To generate BEAM bytecode from Erlang source code}%
}\\\hline%
\emph{Command} & \emph{Effect} \\\hline
  \lstinline[]!erlc module.erl! &%
  Generates an Erlang BEAM file \texttt{module.beam}
\\\hline%
\multicolumn{2}{|l|}{%
  \textbf{To generate BEAM assembly from Erlang source code}%
}\\\hline%
\emph{Command} & \emph{Effect} \\\hline
  \lstinline[]!erlc -S module.erl! &%
  Generates an ASCII text file \texttt{module.S}
\\\hline%
\multicolumn{2}{|l|}{%
  \textbf{To generate BEAM assembly from Erlang source code}%
}\\\hline%
\emph{Command} & \emph{Effect} \\\hline
  \lstinline[]!erlc -S module.erl! &%
  Generates an ASCII text file \texttt{module.S}
\\\hline%
\multicolumn{2}{|l|}{%
  \textbf{To generate Core Erlang code from Erlang source code}%
}\\\hline%
\emph{Command} & \emph{Effect} \\\hline
  \lstinline[]!erlc +to_core module.erl! &%
  Generates an ASCII text file \texttt{module.core}
\\\hline%
\end{tabular}

\end{table}

\begin{figure}[ht!]
\centering
\tikzstyle{block} = [rectangle, draw, 
    text width=6em, text centered, rounded corners,
    node distance=3em,
    minimum height=3em]
\tikzstyle{line} = [draw, -latex']
\tikzstyle{optimizing} = [line width=0.2em]
\footnotesize
\begin{tikzpicture}[auto]
\node (bin) [block] {%
  BEAM bytecode
  \texttt{m.beam}%
};
\node (source) [block, left=9em of bin] {%
  Erlang source code\\
  \texttt{m.erl}%
};
\node (asm) [block, below=3em of bin] {%
  BEAM assembly\\
  \texttt{m.S}%
};
\node (core) [block, below=3em of asm] {%
  Core Erlang
  \texttt{m.core}%
};
\path [line] (source) edge (bin);
\path [line] (source) edge [bend right=30] node [below left] {%
  \lstinline{+to_core}%
} (core);
\path [line] (source) edge [bend right=20] node [above right=0.5em] {%
  \lstinline{+to_asm} (or \lstinline{-S})%
} (asm);
\path [line] (core) edge [bend right=40] node [left] {%
  \lstinline{+to_asm} (or \lstinline{-S})%
} (asm);
\path [line] (core) edge [bend right=90] (bin);
\path [line] (asm) edge [bend right=40] (bin);
\end{tikzpicture}

\caption{An illustration of the options to pass to \texttt{erlc},
depending on the input file, and desired output file. No options are
necessary, if the desired output is a BEAM bytecode file
(\texttt{.beam})}
\label{fig:erlc-cli}
\end{figure}

However, the Erlang/OTP compiler is an optimising compiler. Various
optimisations are performed on both the Core Erlang representation,
and the BEAM assembly representation. Optimisations take place in two
stages because the two representations suitable for each their own
class of optimisations. In particular, Core Erlang is a piecewise
functional language, while BEAM assembly is inherently imperative.

Depending on the extent of optimisations that we conduct ourselves, it
may be better to generate code in on of the earlier, rather than
latter formats.

% Probably the best-specified and most stable of these is Core
% Erlang\cite{erlang:erlang:2001:core-intro, erlang:2004:core-spec}.

% Erlang The BEAM Book suggests that ``Core Erlang is the best target
% for a language you want to run in ERTS''. The reasons mentioned are
% that Core Erlang is less subject to change than the languages of
% BEAM and Erlang.

% https://github.com/erlang/otp/blob/master/lib/compiler/src/cerl.erl
